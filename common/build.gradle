import com.github.jengelman.gradle.plugins.shadow.transformers.Log4j2PluginsCacheFileTransformer

apply plugin: "com.gradleup.shadow"
apply plugin: "net.neoforged.moddev"

version = mod_version

base {
    archivesName = "Discord-MC-Chat-common"
}

dependencies {
    shadow("net.dv8tion:JDA:5.6.1") {
        exclude module: "opus-java" // for encoding audio into opus
        exclude module: "tink" // for encrypting and decrypting audio
        exclude module: "slf4j-api"
        exclude module: "jackson-core"
        exclude module: "jackson-databind"
        exclude module: "jackson-annotations"
    }

    shadow("org.slf4j:slf4j-api:2.0.17")
    shadow("org.slf4j:slf4j-jdk14:2.0.17")

    shadow("com.fasterxml.jackson.core:jackson-databind:2.19.2")
    shadow("com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.19.2")
}

neoForge {
    version = neo_version
}

tasks.withType(JavaCompile).configureEach {
    options.release = 21
    options.encoding = "UTF-8"
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

jar {
    manifest {
        attributes "Main-Class": "com.xujiayao.discord_mc_chat.common.DMCC"
    }
}

shadowJar {
    dependsOn assemble

    archiveBaseName.set("Discord-MC-Chat")
    archiveClassifier.set("")
    configurations = [project.configurations.shadow]
    mergeServiceFiles()
    minimize {
        exclude(dependency("org.slf4j:slf4j-jdk14"))
    }

    exclude "**/*-info.class"
    exclude "META-INF/maven/"
    exclude "META-INF/proguard/"
    exclude "META-INF/versions/11/"
    exclude "META-INF/versions/17/"
    exclude {
        def path = it.path
        path.startsWith("META-INF/") &&
                path.contains("LICENSE") &&
                path != "META-INF/THIRD-PARTY-LICENSES.txt"
    }
    exclude "META-INF/*NOTICE*"
    exclude "META-INF/*kotlin_module*"

    transform(Log4j2PluginsCacheFileTransformer.class)

    relocate "com.fasterxml", "dmcc_dep.com.fasterxml"
    relocate "com.neovisionaries", "dmcc_dep.com.neovisionaries"
    relocate "gnu", "dmcc_dep.gnu"
    relocate "kotlin", "dmcc_dep.kotlin"
    relocate "net.dv8tion", "dmcc_dep.net.dv8tion"
    relocate "okhttp3", "dmcc_dep.okhttp3"
    relocate "okio", "dmcc_dep.okio"
    relocate "org.apache", "dmcc_dep.org.apache"
    relocate "org.intellij", "dmcc_dep.org.intellij"
    relocate "org.jetbrains", "dmcc_dep.org.jetbrains"
    relocate "org.slf4j", "dmcc_dep.org.slf4j"

    from "../LICENSE"
}

//========== Merge JARs ==========

def otherSubprojects = rootProject.subprojects.findAll { it.name != project.name }

tasks.register("mergeJars") {
    dependsOn otherSubprojects.collect { ":$it.name:jar" }
    dependsOn shadowJar

    def shadowJarFile = tasks.shadowJar.archiveFile.get().asFile
    def tempDir = project.layout.buildDirectory.dir("merged_temp").get().asFile

    doLast {
        tempDir.mkdirs()
        def addedFiles = [:]
        otherSubprojects.each { subproj ->
            def jarFile = subproj.tasks.named("jar").get().archiveFile.get().asFile
            copy {
                from zipTree(jarFile)
                into tempDir
                exclude "META-INF/MANIFEST.MF"
                eachFile { fcd ->
                    def relPath = fcd.relativePath.toString()
                    if (addedFiles.containsKey(relPath)) {
                        logger.warn("Warning: Duplicate file found: $relPath in ${subproj.name} and ${addedFiles[relPath]}")
                    } else {
                        addedFiles[relPath] = subproj.name
                    }
                }
            }
        }
        // 将解压后的内容加入 common 的 jar
        ant.zip(update: "true", destfile: shadowJarFile) {
            fileset(dir: tempDir)
        }
    }
}

build {
    dependsOn shadowJar
    dependsOn tasks.named("mergeJars")

    doLast {
        copy {
            from "build/libs"
            into "../build"
            exclude "*common*"
        }
    }
}
